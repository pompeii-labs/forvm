import supabase from '../util/supabase.js';

const autoGeneratedFields = ['id', 'created_at'] as const;
export type AutoGeneratedField = (typeof autoGeneratedFields)[number];

const immutableFields = ['id', 'created_at'] as const;
export type ImmutableField = (typeof immutableFields)[number];

export type GenericData = {
    id: number | string;
};

export type GenericDataInsert<T> = Omit<T, AutoGeneratedField>;
export type GenericDataUpdate<T> = Partial<Omit<T, ImmutableField>>;

export type FilterOperator =
    | 'eq'
    | 'neq'
    | 'gt'
    | 'gte'
    | 'lt'
    | 'lte'
    | 'like'
    | 'ilike'
    | 'is'
    | 'in';

export type DataModelConstructor<M extends DataModel<T>, T extends GenericData> = {
    new (data: T): M;
    tableName: string;
    schema: string;
};

export class DataModel<T extends GenericData> {
    id!: T['id'];

    static readonly tableName: string;
    static readonly schema: string = 'public';

    static async create<
        M extends DataModel<T>,
        T extends GenericData,
        K extends GenericDataInsert<T>,
    >(this: DataModelConstructor<M, T>, fields: K): Promise<M> {
        const { data, error } = await supabase
            .schema(this.schema)
            .from(this.tableName)
            .insert(fields)
            .select()
            .single();

        if (error) throw error;

        return new this(data);
    }

    static async get<M extends DataModel<T>, T extends GenericData>(
        this: DataModelConstructor<M, T>,
        id: T['id'],
    ): Promise<M | null> {
        const { data, error } = await supabase
            .schema(this.schema)
            .from(this.tableName)
            .select()
            .eq('id', id)
            .maybeSingle();

        if (error) {
            if (error.code === 'PGRST116') {
                return null;
            }
            throw error;
        }

        return data ? new this(data) : null;
    }

    static async list<M extends DataModel<T>, T extends GenericData>(
        this: DataModelConstructor<M, T>,
        ...options: {
            [K in keyof T]: {
                column: K;
                operator: FilterOperator;
                value: T[K] | T[K][];
            };
        }[keyof T][]
    ): Promise<M[]> {
        const query = supabase.schema(this.schema).from(this.tableName).select();

        for (const option of options.filter(Boolean)) {
            (query as any)[option.operator.toString()](option.column, option.value);
        }

        const { data, error } = await query;

        if (error) {
            if (error.code === 'PGRST116') {
                return [];
            }
            throw error;
        }

        return data.map((d) => new this(d));
    }

    static async update<
        M extends DataModel<T>,
        T extends GenericData,
        K extends GenericDataUpdate<T>,
    >(this: DataModelConstructor<M, T>, id: T['id'], fields: K): Promise<M | null> {
        const { data, error } = await supabase
            .schema(this.schema)
            .from(this.tableName)
            .update(fields)
            .eq('id', id)
            .select()
            .single();

        if (error) throw error;

        return new this(data);
    }

    static async delete<M extends DataModel<T>, T extends GenericData>(
        this: DataModelConstructor<M, T>,
        id: T['id'],
    ): Promise<void> {
        const { error } = await supabase
            .schema(this.schema)
            .from(this.tableName)
            .delete()
            .eq('id', id);

        if (error) throw error;
    }

    async update(fields: GenericDataUpdate<T>): Promise<void> {
        const { tableName, schema } = this.getConstructor();

        const { error } = await supabase
            .schema(schema)
            .from(tableName)
            .update(fields)
            .eq('id', this.id);

        if (error) throw error;

        Object.assign(this, fields);
    }

    async delete(): Promise<void> {
        const { tableName, schema } = this.getConstructor();

        const { error } = await supabase.schema(schema).from(tableName).delete().eq('id', this.id);

        if (error) throw error;
    }

    getConstructor(): DataModelConstructor<DataModel<T>, T> {
        return this.constructor as DataModelConstructor<DataModel<T>, T>;
    }
}
